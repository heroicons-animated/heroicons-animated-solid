{
  "$schema": "https://shadcn-solid.com/schema.json",
  "name": "motion-compat",
  "title": "motion-compat",
  "description": "Shared motion compatibility helpers for SolidJS icons",
  "type": "registry:ui",
  "registryDependencies": [],
  "dependencies": [],
  "files": [
    {
      "path": "lib/motion-compat.ts",
      "type": "registry:ui",
      "content": "/**\n * Compatibility layer for converting Framer Motion variant format\n * to solid-motionone animate/transition props at runtime.\n */\n\nconst EASE_MAP: Record<string, string> = {\n  easeInOut: \"ease-in-out\",\n  easeIn: \"ease-in\",\n  easeOut: \"ease-out\",\n  linear: \"linear\",\n};\n\nfunction convertEase(ease: string | number[]): string {\n  if (Array.isArray(ease)) {\n    return `cubic-bezier(${ease.join(\",\")})`;\n  }\n  return EASE_MAP[ease] ?? ease;\n}\n\nfunction toFiniteNumber(value: unknown): number | undefined {\n  if (typeof value !== \"number\" || !Number.isFinite(value)) {\n    return undefined;\n  }\n  return value;\n}\n\n// biome-ignore lint/suspicious/noExplicitAny: Motion One options vary by property at runtime.\ntype TransitionObj = Record<string, any>;\ntype TransitionKey = string;\n\nfunction resolveSpringDuration(source: TransitionObj): number {\n  const stiffness = toFiniteNumber(source.stiffness) ?? 100;\n  const damping = toFiniteNumber(source.damping) ?? 12;\n  const mass = toFiniteNumber(source.mass) ?? 0.4;\n  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n\n  if (dampingRatio >= 1) {\n    return 0.28;\n  }\n  if (dampingRatio >= 0.6) {\n    return 0.34;\n  }\n  return 0.42;\n}\n\nfunction applySpecialTransitionKey(\n  key: TransitionKey,\n  value: unknown,\n  source: TransitionObj,\n  target: TransitionObj\n): boolean {\n  switch (key) {\n    case \"ease\":\n      target.easing = convertEase(value as string | number[]);\n      return true;\n    case \"times\":\n      target.offset = value;\n      return true;\n    case \"repeatType\":\n      if (value === \"reverse\") {\n        target.direction = \"alternate\";\n      }\n      return true;\n    case \"repeatDelay\":\n      target.endDelay = value;\n      return true;\n    case \"type\":\n      if (value === \"spring\") {\n        if (!(\"duration\" in source)) {\n          target.duration = resolveSpringDuration(source);\n        }\n        if (!(\"easing\" in target)) {\n          target.easing = \"cubic-bezier(0.22,1,0.36,1)\";\n        }\n      }\n      return true;\n    case \"bounce\":\n      if (source.type !== \"spring\") {\n        target.easing = \"cubic-bezier(0.34,1.56,0.64,1)\";\n      }\n      return true;\n    default:\n      return false;\n  }\n}\n\nfunction isTransitionObject(value: unknown): value is TransitionObj {\n  return typeof value === \"object\" && value !== null && !Array.isArray(value);\n}\n\nfunction mapPathDrawTransitionKey(\n  key: string,\n  value: unknown,\n  target: TransitionObj\n): boolean {\n  if (key === \"pathLength\") {\n    if (isTransitionObject(value)) {\n      target.strokeDasharray = convertTransitionObj(value as TransitionObj);\n    }\n    return true;\n  }\n  if (key === \"pathOffset\") {\n    if (isTransitionObject(value)) {\n      target.strokeDashoffset = convertTransitionObj(value as TransitionObj);\n    }\n    return true;\n  }\n  if (key === \"pathSpacing\") {\n    if (isTransitionObject(value) && !(\"strokeDasharray\" in target)) {\n      target.strokeDasharray = convertTransitionObj(value as TransitionObj);\n    }\n    return true;\n  }\n  return false;\n}\n\nfunction convertTransitionObj(t: TransitionObj): TransitionObj {\n  const r: TransitionObj = {};\n  const skip = new Set([\n    \"stiffness\",\n    \"damping\",\n    \"mass\",\n    \"type\",\n    \"bounce\",\n    \"ease\",\n    \"times\",\n    \"repeatType\",\n    \"repeatDelay\",\n  ]);\n\n  for (const [k, v] of Object.entries(t)) {\n    if (mapPathDrawTransitionKey(k, v, r)) {\n      continue;\n    }\n    if (applySpecialTransitionKey(k, v, t, r) || skip.has(k)) {\n      continue;\n    }\n    if (isTransitionObject(v)) {\n      // Per-property transition (e.g. { opacity: { duration: 0.2 } })\n      r[k] = convertTransitionObj(v as TransitionObj);\n      continue;\n    }\n    r[k] = v;\n  }\n  return r;\n}\n\n// biome-ignore lint/suspicious/noExplicitAny: Variant payload is dynamic and icon-specific.\ntype VariantValue = Record<string, any>;\n// biome-ignore lint/suspicious/noExplicitAny: Custom payload can be number or object depending on icon variant usage.\ntype VariantDef = VariantValue | ((custom: any) => VariantValue);\ntype Variants = Record<string, VariantDef>;\n\nconst CSS_PATH_PREFIX = \"path(\";\n\nfunction toCssPath(pathData: string): string {\n  const normalized = pathData.trim();\n  if (normalized.startsWith(CSS_PATH_PREFIX)) {\n    return normalized;\n  }\n  return `path(\"${normalized.replace(/\"/g, '\\\\\"')}\")`;\n}\n\nfunction resolvePathValue(value: unknown): unknown {\n  if (typeof value === \"string\") {\n    return toCssPath(value);\n  }\n  if (Array.isArray(value)) {\n    return value.map((item) =>\n      typeof item === \"string\" ? toCssPath(item) : item\n    );\n  }\n  return value;\n}\n\nfunction toKeyframes(value: unknown, fallback: unknown): unknown[] {\n  if (Array.isArray(value)) {\n    return value.length > 0 ? value : [fallback];\n  }\n  if (value === undefined) {\n    return [fallback];\n  }\n  return [value];\n}\n\nfunction normalizeKeyframes(values: unknown[], frameCount: number): unknown[] {\n  if (values.length === frameCount) {\n    return values;\n  }\n  if (values.length === 1) {\n    return new Array(frameCount).fill(values[0]);\n  }\n\n  const normalized: unknown[] = [];\n  for (let index = 0; index < frameCount; index += 1) {\n    normalized.push(values[Math.min(index, values.length - 1)]);\n  }\n  return normalized;\n}\n\nfunction negatePathOffset(value: unknown): unknown {\n  if (typeof value === \"number\") {\n    return -value;\n  }\n  if (typeof value === \"string\") {\n    const normalized = value.trim();\n    if (normalized.length === 0) {\n      return normalized;\n    }\n    if (normalized.startsWith(\"-\")) {\n      return normalized.slice(1);\n    }\n    return `-${normalized}`;\n  }\n  return value;\n}\n\nfunction applyPathDrawCompat(values: VariantValue): void {\n  const hasPathDrawValues =\n    \"pathLength\" in values || \"pathOffset\" in values || \"pathSpacing\" in values;\n  if (!hasPathDrawValues) {\n    return;\n  }\n\n  const pathLengthFrames = toKeyframes(values.pathLength, 1);\n  const pathOffsetFrames = toKeyframes(values.pathOffset, 0);\n  const pathSpacingFrames = toKeyframes(values.pathSpacing, 1);\n  const frameCount = Math.max(\n    pathLengthFrames.length,\n    pathOffsetFrames.length,\n    pathSpacingFrames.length\n  );\n\n  const normalizedPathLength = normalizeKeyframes(pathLengthFrames, frameCount);\n  const normalizedPathOffset = normalizeKeyframes(pathOffsetFrames, frameCount);\n  const normalizedPathSpacing = normalizeKeyframes(\n    pathSpacingFrames,\n    frameCount\n  );\n\n  const strokeDasharray = normalizedPathLength.map(\n    (length, index) => `${length} ${normalizedPathSpacing[index]}`\n  );\n  const strokeDashoffset = normalizedPathOffset.map((offset) =>\n    negatePathOffset(offset)\n  );\n\n  values.pathLength = 1;\n  values.strokeDasharray =\n    strokeDasharray.length === 1 ? strokeDasharray[0] : strokeDasharray;\n  values.strokeDashoffset =\n    strokeDashoffset.length === 1 ? strokeDashoffset[0] : strokeDashoffset;\n\n  values.pathOffset = undefined;\n  values.pathSpacing = undefined;\n}\n\nfunction toTransformOriginPart(value: unknown, fallback: string): string {\n  if (typeof value === \"number\") {\n    return `${value * 100}%`;\n  }\n  if (typeof value === \"string\" && value.length > 0) {\n    return value;\n  }\n  return fallback;\n}\n\n/**\n * Resolve the animation values from a variant definition.\n * Returns only the CSS/transform properties (no transition).\n */\nexport function resolveValues(\n  variants: Variants,\n  variantName: string,\n  // biome-ignore lint/suspicious/noExplicitAny: Custom payload shape varies per icon.\n  custom: any = 0\n  // biome-ignore lint/suspicious/noExplicitAny: Returned object is forwarded to Motion animate prop.\n): any {\n  const def = variants[variantName];\n  if (!def) {\n    return {};\n  }\n  const state = typeof def === \"function\" ? def(custom) : def;\n  const { transition: _t, originX, originY, ...values } = state;\n\n  if (originX !== undefined || originY !== undefined) {\n    const x = toTransformOriginPart(originX, \"50%\");\n    const y = toTransformOriginPart(originY, \"50%\");\n    values.transformOrigin = `${x} ${y}`;\n    values.transformBox = \"fill-box\";\n  }\n\n  if (\"d\" in values) {\n    values.d = resolvePathValue(values.d);\n  }\n  applyPathDrawCompat(values);\n\n  return values;\n}\n\n/**\n * Resolve the transition options from a variant definition.\n * Converts Framer Motion transition format to solid-motionone format.\n */\nexport function resolveTransition(\n  variants: Variants,\n  variantName: string,\n  // biome-ignore lint/suspicious/noExplicitAny: Custom payload shape varies per icon.\n  custom: any = 0,\n  extraTransition?: TransitionObj\n  // biome-ignore lint/suspicious/noExplicitAny: Returned object is forwarded to Motion transition prop.\n): any {\n  const def = variants[variantName];\n  if (!(def || extraTransition)) {\n    return {};\n  }\n  let state: VariantValue;\n  if (!def) {\n    state = {};\n  } else if (typeof def === \"function\") {\n    state = def(custom);\n  } else {\n    state = def;\n  }\n  const t = state.transition ?? {};\n  const merged = extraTransition ? { ...t, ...extraTransition } : t;\n  if (Object.keys(merged).length === 0) {\n    return {};\n  }\n  return convertTransitionObj(merged);\n}\n"
    }
  ]
}
